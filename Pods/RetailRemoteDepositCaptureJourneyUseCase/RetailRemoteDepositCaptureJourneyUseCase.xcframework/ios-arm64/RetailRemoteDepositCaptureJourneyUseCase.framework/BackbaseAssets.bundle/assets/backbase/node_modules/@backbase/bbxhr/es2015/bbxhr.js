/**
 * Name: bbxhr
 * Description: A custom implementation of XMLHttpRequest that uses the BBXHR plugin
 * Version: 1.0.0-rc.71
 * SHA-1: b4a9e340849b383a47f1ac1331cb0970d7d15981
 */
(function(exports){"use strict";(function(self){var support={searchParams:"URLSearchParams"in self,iterable:"Symbol"in self&&"iterator"in Symbol,blob:"FileReader"in self&&"Blob"in self&&function(){try{new Blob;return true}catch(e){return false}}(),formData:"FormData"in self,arrayBuffer:"ArrayBuffer"in self};if(support.arrayBuffer){var viewClasses=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"];var isDataView=function(obj){return obj&&DataView.prototype.isPrototypeOf(obj)};var isArrayBufferView=ArrayBuffer.isView||function(obj){return obj&&viewClasses.indexOf(Object.prototype.toString.call(obj))>-1}}function normalizeName(name){if(typeof name!=="string"){name=String(name)}if(/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)){throw new TypeError("Invalid character in header field name")}return name.toLowerCase()}function normalizeValue(value){if(typeof value!=="string"){value=String(value)}return value}function iteratorFor(items){var iterator={next:function(){var value=items.shift();return{done:value===undefined,value:value}}};if(support.iterable){iterator[Symbol.iterator]=function(){return iterator}}return iterator}function Headers(headers){this.map={};if(headers instanceof Headers){headers.forEach((function(value,name){this.append(name,value)}),this)}else if(Array.isArray(headers)){headers.forEach((function(header){this.append(header[0],header[1])}),this)}else if(headers){Object.getOwnPropertyNames(headers).forEach((function(name){this.append(name,headers[name])}),this)}}Headers.prototype.append=function(name,value){name=normalizeName(name);value=normalizeValue(value);var oldValue=this.map[name];this.map[name]=oldValue?oldValue+","+value:value};Headers.prototype["delete"]=function(name){delete this.map[normalizeName(name)]};Headers.prototype.get=function(name){name=normalizeName(name);return this.has(name)?this.map[name]:null};Headers.prototype.has=function(name){return this.map.hasOwnProperty(normalizeName(name))};Headers.prototype.set=function(name,value){this.map[normalizeName(name)]=normalizeValue(value)};Headers.prototype.forEach=function(callback,thisArg){for(var name in this.map){if(this.map.hasOwnProperty(name)){callback.call(thisArg,this.map[name],name,this)}}};Headers.prototype.keys=function(){var items=[];this.forEach((function(value,name){items.push(name)}));return iteratorFor(items)};Headers.prototype.values=function(){var items=[];this.forEach((function(value){items.push(value)}));return iteratorFor(items)};Headers.prototype.entries=function(){var items=[];this.forEach((function(value,name){items.push([name,value])}));return iteratorFor(items)};if(support.iterable){Headers.prototype[Symbol.iterator]=Headers.prototype.entries}function consumed(body){if(body.bodyUsed){return Promise.reject(new TypeError("Already read"))}body.bodyUsed=true}function fileReaderReady(reader){return new Promise((function(resolve,reject){reader.onload=function(){resolve(reader.result)};reader.onerror=function(){reject(reader.error)}}))}function readBlobAsArrayBuffer(blob){var reader=new FileReader;var promise=fileReaderReady(reader);reader.readAsArrayBuffer(blob);return promise}function readBlobAsText(blob){var reader=new FileReader;var promise=fileReaderReady(reader);reader.readAsText(blob);return promise}function readArrayBufferAsText(buf){var view=new Uint8Array(buf);var chars=new Array(view.length);for(var i=0;i<view.length;i++){chars[i]=String.fromCharCode(view[i])}return chars.join("")}function bufferClone(buf){if(buf.slice){return buf.slice(0)}else{var view=new Uint8Array(buf.byteLength);view.set(new Uint8Array(buf));return view.buffer}}function Body(){this.bodyUsed=false;this._initBody=function(body){this._bodyInit=body;if(!body){this._bodyText=""}else if(typeof body==="string"){this._bodyText=body}else if(support.blob&&Blob.prototype.isPrototypeOf(body)){this._bodyBlob=body}else if(support.formData&&FormData.prototype.isPrototypeOf(body)){this._bodyFormData=body}else if(support.searchParams&&URLSearchParams.prototype.isPrototypeOf(body)){this._bodyText=body.toString()}else if(support.arrayBuffer&&support.blob&&isDataView(body)){this._bodyArrayBuffer=bufferClone(body.buffer);this._bodyInit=new Blob([this._bodyArrayBuffer])}else if(support.arrayBuffer&&(ArrayBuffer.prototype.isPrototypeOf(body)||isArrayBufferView(body))){this._bodyArrayBuffer=bufferClone(body)}else{throw new Error("unsupported BodyInit type")}if(!this.headers.get("content-type")){if(typeof body==="string"){this.headers.set("content-type","text/plain;charset=UTF-8")}else if(this._bodyBlob&&this._bodyBlob.type){this.headers.set("content-type",this._bodyBlob.type)}else if(support.searchParams&&URLSearchParams.prototype.isPrototypeOf(body)){this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8")}}};if(support.blob){this.blob=function(){var rejected=consumed(this);if(rejected){return rejected}if(this._bodyBlob){return Promise.resolve(this._bodyBlob)}else if(this._bodyArrayBuffer){return Promise.resolve(new Blob([this._bodyArrayBuffer]))}else if(this._bodyFormData){throw new Error("could not read FormData body as blob")}else{return Promise.resolve(new Blob([this._bodyText]))}};this.arrayBuffer=function(){if(this._bodyArrayBuffer){return consumed(this)||Promise.resolve(this._bodyArrayBuffer)}else{return this.blob().then(readBlobAsArrayBuffer)}}}this.text=function(){var rejected=consumed(this);if(rejected){return rejected}if(this._bodyBlob){return readBlobAsText(this._bodyBlob)}else if(this._bodyArrayBuffer){return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))}else if(this._bodyFormData){throw new Error("could not read FormData body as text")}else{return Promise.resolve(this._bodyText)}};if(support.formData){this.formData=function(){return this.text().then(decode)}}this.json=function(){return this.text().then(JSON.parse)};return this}var methods=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];function normalizeMethod(method){var upcased=method.toUpperCase();return methods.indexOf(upcased)>-1?upcased:method}function Request(input,options){options=options||{};var body=options.body;if(input instanceof Request){if(input.bodyUsed){throw new TypeError("Already read")}this.url=input.url;this.credentials=input.credentials;if(!options.headers){this.headers=new Headers(input.headers)}this.method=input.method;this.mode=input.mode;if(!body&&input._bodyInit!=null){body=input._bodyInit;input.bodyUsed=true}}else{this.url=String(input)}this.credentials=options.credentials||this.credentials||"omit";if(options.headers||!this.headers){this.headers=new Headers(options.headers)}this.method=normalizeMethod(options.method||this.method||"GET");this.mode=options.mode||this.mode||null;this.referrer=null;if((this.method==="GET"||this.method==="HEAD")&&body){throw new TypeError("Body not allowed for GET or HEAD requests")}this._initBody(body)}Request.prototype.clone=function(){return new Request(this,{body:this._bodyInit})};function decode(body){var form=new FormData;body.trim().split("&").forEach((function(bytes){if(bytes){var split=bytes.split("=");var name=split.shift().replace(/\+/g," ");var value=split.join("=").replace(/\+/g," ");form.append(decodeURIComponent(name),decodeURIComponent(value))}}));return form}function parseHeaders(rawHeaders){var headers=new Headers;var preProcessedHeaders=rawHeaders.replace(/\r?\n[\t ]+/g," ");preProcessedHeaders.split(/\r?\n/).forEach((function(line){var parts=line.split(":");var key=parts.shift().trim();if(key){var value=parts.join(":").trim();headers.append(key,value)}}));return headers}Body.call(Request.prototype);function Response(bodyInit,options){if(!options){options={}}this.type="default";this.status=options.status===undefined?200:options.status;this.ok=this.status>=200&&this.status<300;this.statusText="statusText"in options?options.statusText:"OK";this.headers=new Headers(options.headers);this.url=options.url||"";this._initBody(bodyInit)}Body.call(Response.prototype);Response.prototype.clone=function(){return new Response(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new Headers(this.headers),url:this.url})};Response.error=function(){var response=new Response(null,{status:0,statusText:""});response.type="error";return response};var redirectStatuses=[301,302,303,307,308];Response.redirect=function(url,status){if(redirectStatuses.indexOf(status)===-1){throw new RangeError("Invalid status code")}return new Response(null,{status:status,headers:{location:url}})};self.Headers=Headers;self.Request=Request;self.Response=Response;self.fetch=function(input,init){return new Promise((function(resolve,reject){var request=new Request(input,init);var xhr=new XMLHttpRequest;xhr.onload=function(){var options={status:xhr.status,statusText:xhr.statusText,headers:parseHeaders(xhr.getAllResponseHeaders()||"")};options.url="responseURL"in xhr?xhr.responseURL:options.headers.get("X-Request-URL");var body="response"in xhr?xhr.response:xhr.responseText;resolve(new Response(body,options))};xhr.onerror=function(){reject(new TypeError("Network request failed"))};xhr.ontimeout=function(){reject(new TypeError("Network request failed"))};xhr.open(request.method,request.url,true);if(request.credentials==="include"){xhr.withCredentials=true}else if(request.credentials==="omit"){xhr.withCredentials=false}request.headers.forEach((function(value,name){xhr.setRequestHeader(name,value)}));xhr.send(typeof request._bodyInit==="undefined"?null:request._bodyInit)}))};self.fetch.polyfill=true})(window);const createDOMParser=()=>new DOMParser;const globalContext=typeof global!=="undefined"?global:window;const createURLParser=()=>{let anchorElement=null;const getAnchorElement=()=>{anchorElement=anchorElement||globalContext.document.createElement("a");return anchorElement};const toAbsoluteURI=url=>{try{const element=getAnchorElement();element.href=url;return element.href}catch(err){return""}};return{toAbsoluteURI:toAbsoluteURI}};const nativeIsFiniteNumber=Number.isFinite;const isFile=testValue=>Object.prototype.toString.call(testValue)==="[object File]"||testValue instanceof File;const isFormData=testValue=>Object.prototype.toString.call(testValue)==="[object FormData]"||testValue instanceof FormData;const isHTMLDocument=testValue=>Object.prototype.toString.call(testValue)==="[object HTMLDocument]";const isFiniteNumber=testValue=>nativeIsFiniteNumber(testValue);const isFunction=testValue=>typeof testValue==="function";const isNegativeZero=testValue=>testValue===0&&1/testValue===-Infinity;const hasValue=(target,propertyName)=>{const descriptor=Object.getOwnPropertyDescriptor(target,propertyName);return descriptor?{}.hasOwnProperty.call(descriptor,"value"):false};const nativeToString=function toString(){return`function toString() {\n    [bbxhr code]\n}`};const createNativeToString=methodName=>{if(methodName==="toString"){return nativeToString}function toString(){return`function ${methodName}() {\n    [bbxhr code]\n}`}toString.toString=nativeToString;return toString};const exposeConstant=(target,constantName,constantValue)=>{Object.defineProperty(target,constantName,{configurable:false,enumerable:true,value:constantValue,writable:false})};const makeMembersEnumerable=target=>{Object.getOwnPropertyNames(target).forEach((propertyName=>{Object.defineProperty(target,propertyName,{enumerable:true})}))};const applyCustomToString=target=>{Object.keys(target).filter((propertyName=>hasValue(target,propertyName))).filter((propertyName=>isFunction(target[propertyName]))).forEach((methodName=>{target[methodName].toString=createNativeToString(methodName)}))};const testDOMException=()=>{try{new DOMException("Test");return true}catch(err){return false}};const canCreateDOMException=testDOMException();const createDOMException=message=>canCreateDOMException?new DOMException(message):new Error(message);const createPlainError=message=>new Error(message);const createPlainTypeError=message=>new TypeError(message);const createErrorFactory=componentName=>message=>createPlainError(`[${componentName}] ${message}`);const isNativeAvailable=typeof Symbol==="function";const createSymbol=description=>isNativeAvailable?Symbol(description):`Symbol(${description})`;const createEventTargetInternals=()=>({listenerRegistry:new Map});var _a;const INTERNALS_KEY=createSymbol("[[EventTargetInternals]]");const getListenerRegistry=instance=>instance[INTERNALS_KEY].listenerRegistry;class EventTarget{constructor(){this[_a]=createEventTargetInternals()}addEventListener(eventType,callback){const listenerRegistry=getListenerRegistry(this);const listeners=listenerRegistry.get(eventType)||[];if(!listenerRegistry.has(eventType)){listenerRegistry.set(eventType,listeners)}listeners.push(callback)}dispatchEvent(event){const listenerRegistry=getListenerRegistry(this);const listeners=listenerRegistry.get(event.type);if(!listeners){return true}const listenersCopy=listeners.slice();listenersCopy.forEach((listener=>{listener.call(this,event)}));return!event.defaultPrevented}removeEventListener(eventType,eventListener){const listenerRegistry=getListenerRegistry(this);const listeners=listenerRegistry.get(eventType);if(!listeners){return}listeners.forEach(((currentListener,index)=>{if(currentListener===eventListener){listeners.splice(index,1);return}}))}}_a=INTERNALS_KEY;const EventTargetPrototype=EventTarget.prototype;makeMembersEnumerable(EventTargetPrototype);applyCustomToString(EventTargetPrototype);const isConstructibleEventTargetSupported=()=>{try{new window.EventTarget;return true}catch(error){return false}};const EventTarget$1=isConstructibleEventTargetSupported()?window.EventTarget:EventTarget;const createXMLHttpRequestEventTargetInternals=()=>({onabortValue:null,onerrorValue:null,onloadValue:null,onloadendValue:null,onloadstartValue:null,onprogressValue:null,ontimeoutValue:null});var _a$1;const INTERNALS_KEY$1=createSymbol("[[XMLHttpRequestEventTargetInternals]]");const getInternals=instance=>instance[INTERNALS_KEY$1];const normalizeListener=listener=>isFunction(listener)?listener:null;class XMLHttpRequestEventTarget extends EventTarget$1{constructor(){super(...arguments);this[_a$1]=createXMLHttpRequestEventTargetInternals()}get onabort(){return getInternals(this).onabortValue}set onabort(listener){getInternals(this).onabortValue=normalizeListener(listener)}get onerror(){return getInternals(this).onerrorValue}set onerror(listener){getInternals(this).onerrorValue=normalizeListener(listener)}get onload(){return getInternals(this).onloadValue}set onload(listener){getInternals(this).onloadValue=normalizeListener(listener)}get onloadend(){return getInternals(this).onloadendValue}set onloadend(listener){getInternals(this).onloadendValue=normalizeListener(listener)}get onloadstart(){return getInternals(this).onloadstartValue}set onloadstart(listener){getInternals(this).onloadstartValue=normalizeListener(listener)}get onprogress(){return getInternals(this).onprogressValue}set onprogress(listener){getInternals(this).onprogressValue=normalizeListener(listener)}get ontimeout(){return getInternals(this).ontimeoutValue}set ontimeout(listener){getInternals(this).ontimeoutValue=normalizeListener(listener)}}_a$1=INTERNALS_KEY$1;makeMembersEnumerable(XMLHttpRequestEventTarget.prototype);applyCustomToString(XMLHttpRequestEventTarget.prototype);const DEFAULT_MIME_TYPE_TEXT_HTML="text/html;charset=UTF-8";const DEFAULT_MIME_TYPE_TEXT_PLAIN="text/plain;charset=UTF-8";const DEFAULT_PLUGIN_TIMEOUT=864e5;const INTERNALS_KEY$2=createSymbol("[[XMLHttpRequestInternals]]");const FORBIDDEN_HTTP_METHODS=["connect","trace","track"];const FORBIDDEN_REQUEST_HEADERS=["accept-charset","accept-encoding","access-control-request-headers","access-control-request-method","connection","content-length","cookie","cookie2","date","dnt","expect","host","keep-alive","origin","referer","te","trailer","transfer-encoding","upgrade","via"];const FORBIDDEN_REQUEST_HEADERS_RE=[/^proxy-/,/^sec-/];const HEADER_CONTENT_TYPE="Content-Type";const HTTP_METHOD_RE=/^[\w+-~!#]+$/;const STANDARD_HTTP_METHODS=["connect","delete","get","head","options","patch","post","put","trace","track"];const SUPPORTED_RESPONSE_TYPE=["","arraybuffer","blob","document","json","text"];const SUPPORTED_RESPONSE_TYPE_DOCUMENT_MIME_TYPE=["text/html","text/xml","application/xml","application/xhtml+xml","image/svg+xml"];const READY_STATE_DONE="DONE";const READY_STATE_HEADERS_RECEIVED="HEADERS_RECEIVED";const READY_STATE_LOADING="LOADING";const READY_STATE_OPENED="OPENED";const READY_STATE_UNSENT="UNSENT";var StatusText;(function(StatusText){StatusText["Accepted"]="Accepted";StatusText["AlreadyReported"]="Already Reported";StatusText["BadGateway"]="Bad Gateway";StatusText["BadRequest"]="Bad Request";StatusText["Conflict"]="Conflict";StatusText["Created"]="Created";StatusText["ExpectationFailed"]="Expectation Failed";StatusText["FailedDependency"]="Failed Dependency";StatusText["Forbidden"]="Forbidden";StatusText["GatewayTimeout"]="Gateway Timeout";StatusText["Gone"]="Gone";StatusText["HTTPVersionNotSupported"]="HTTP Version Not Supported";StatusText["IMUsed"]="IM Used";StatusText["InsufficientStorage"]="Insufficient Storage";StatusText["InternalServerError"]="Internal Server Error";StatusText["LengthRequired"]="Length Required";StatusText["Locked"]="Locked";StatusText["LoopDetected"]="Loop Detected";StatusText["MethodNotAllowed"]="Method Not Allowed";StatusText["MisdirectedRequest"]="Misdirected Request";StatusText["MultiStatus"]="Multi-Status";StatusText["NetworkAuthenticationRequired"]="Network Authentication Required";StatusText["NoContent"]="No Content";StatusText["NonAuthoritativeInformation"]="Non-Authoritative Information";StatusText["NotAcceptable"]="Not Acceptable";StatusText["NotExtended"]="Not Extended";StatusText["NotFound"]="Not Found";StatusText["NotImplemented"]="Not Implemented";StatusText["OK"]="OK";StatusText["PartialContent"]="Partial Content";StatusText["PayloadTooLarge"]="Payload Too Large";StatusText["PaymentRequired"]="Payment Required";StatusText["PreconditionFailed"]="Precondition Failed";StatusText["PreconditionRequired"]="Precondition Required";StatusText["RangeNotSatisfiable"]="Range Not Satisfiable";StatusText["RequestHeaderFieldsTooLarge"]="Request Header Fields Too Large";StatusText["RequestTimeout"]="Request Timeout";StatusText["ResetContent"]="Reset Content";StatusText["ServiceUnavailable"]="Service Unavailable";StatusText["TooManyRequests"]="Too Many Requests";StatusText["Unauthorized"]="Unauthorized";StatusText["UnavailableForLegalReasons"]="Unavailable For Legal Reasons";StatusText["UnprocessableEntity"]="Unprocessable Entity";StatusText["UnsupportedMediaType"]="Unsupported Media Type";StatusText["UpgradeRequired"]="Upgrade Required";StatusText["URITooLong"]="URI Too Long";StatusText["VariantAlsoNegotiates"]="Variant Also Negotiates";StatusText["Unknown"]="Unknown"})(StatusText||(StatusText={}));
/*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */function __awaiter(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P((function(resolve){resolve(value)}))}return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))}const requestConfigToJSONString=requestConfig=>JSON.stringify(requestConfig);const BBXHRPluginName="BBXHR";var BBXHRPluginRequestErrorName;(function(BBXHRPluginRequestErrorName){BBXHRPluginRequestErrorName["NetworkFailed"]="ERR_NETWORK_FAILED";BBXHRPluginRequestErrorName["RequestAborted"]="ERR_REQUEST_ABORTED";BBXHRPluginRequestErrorName["RequestTimeout"]="ERR_REQUEST_TIMEOUT";BBXHRPluginRequestErrorName["TooManyRedirects"]="ERR_TOO_MANY_REDIRECTS";BBXHRPluginRequestErrorName["Unexpected"]="ERR_UNEXPECTED"})(BBXHRPluginRequestErrorName||(BBXHRPluginRequestErrorName={}));var BBXHRPluginReadyState;(function(BBXHRPluginReadyState){BBXHRPluginReadyState["Pending"]="PENDING";BBXHRPluginReadyState["Initiated"]="INITIATED";BBXHRPluginReadyState["Uploading"]="UPLOADING";BBXHRPluginReadyState["HeadersReceived"]="HEADERS_RECEIVED";BBXHRPluginReadyState["Loading"]="LOADING";BBXHRPluginReadyState["Complete"]="COMPLETE"})(BBXHRPluginReadyState||(BBXHRPluginReadyState={}));let decoder;const byteArrayToString=byteArray=>{if(!decoder){decoder=new TextDecoder}return decoder.decode(byteArray)};const arraySlice=Array.prototype.slice;const byteArrayToArray=byteArray=>arraySlice.call(byteArray);const find=(arr,fn)=>{for(let index=0;index<arr.length;index++){const item=arr[index];if(fn(item,index)){return arr[index]}}};const includes=(arr,item)=>arr.indexOf(item)!==-1;class CustomTextEncoder{encode(text){const textSize=text.length;let resultPosition=-1;const result=new Uint8Array(textSize*3);for(let point=0,nextCode=0,charIndex=0;charIndex!==textSize;){point=text.charCodeAt(charIndex);charIndex++;if(point>=55296&&point<=56319){if(charIndex===textSize){result[resultPosition+=1]=239;result[resultPosition+=1]=191;result[resultPosition+=1]=189;break}nextCode=text.charCodeAt(charIndex);if(nextCode>=56320&&nextCode<=57343){point=(point-55296)*1024+nextCode-56320+65536;charIndex++;if(point>65535){result[resultPosition+=1]=30<<3|point>>>18;result[resultPosition+=1]=2<<6|point>>>12&63;result[resultPosition+=1]=2<<6|point>>>6&63;result[resultPosition+=1]=2<<6|point&63;continue}}else{result[resultPosition+=1]=239;result[resultPosition+=1]=191;result[resultPosition+=1]=189;continue}}if(point<=127){result[resultPosition+=1]=0<<7|point}else if(point<=2047){result[resultPosition+=1]=6<<5|point>>>6;result[resultPosition+=1]=2<<6|point&63}else{result[resultPosition+=1]=14<<4|point>>>12;result[resultPosition+=1]=2<<6|point>>>6&63;result[resultPosition+=1]=2<<6|point&63}}return result.subarray(0,resultPosition+1)}}const createTextEncoder=()=>{const EncoderClass=typeof TextEncoder!=="undefined"?TextEncoder:CustomTextEncoder;return new EncoderClass};const encoder=createTextEncoder();const bytesToHexString=bytes=>byteArrayToArray(bytes).map((byte=>{const byteString=byte.toString(16);return byteString.length===1?`0${byteString}`:byteString})).join("");const throwInvalidHexError=hex=>{throw new TypeError(`Failed to decode the body from the plugin response: `+`Expected a byte as hex string, but received "${hex}"`)};const hexStringToBytes=hexString=>{const charCount=hexString.length;const byteCount=charCount/2;const byteArray=new Uint8Array(byteCount);let byteIndex=0;let byte;let byteHex;for(let charIndex=0;byteIndex<byteCount;charIndex=charIndex+2){byteHex=hexString[charIndex]+hexString[charIndex+1];byte=parseInt(byteHex,16);if(isNaN(byte)){throwInvalidHexError(byteHex)}byteArray[byteIndex]=byte;byteIndex=byteIndex+1}return byteArray};const stringToBytes=string=>encoder.encode(string);const createEvent=eventType=>new Event(eventType,{bubbles:false,cancelable:false});const createProgressEvent=eventType=>new ProgressEvent(eventType,{bubbles:false,cancelable:false});const isZoneJSLoaded=()=>"Zone"in globalContext;const createEventDispatcher=()=>{const dispatchErrorEvent=instance=>{const event=createProgressEvent("error");instance.dispatchEvent(event);if(instance.onerror&&!isZoneJSLoaded()){instance.onerror(event)}};const dispatchLoadEvent=instance=>{const event=createProgressEvent("load");instance.dispatchEvent(event);if(instance.onload&&!isZoneJSLoaded()){instance.onload(event)}};const dispatchReadyStateChangeEvent=instance=>{const event=createEvent("readystatechange");instance.dispatchEvent(event);if(instance.onreadystatechange&&!isZoneJSLoaded()){instance.onreadystatechange(event)}};const dispatchTimeoutEvent=instance=>{const event=createProgressEvent("timeout");instance.dispatchEvent(event);if(instance.ontimeout&&!isZoneJSLoaded()){instance.ontimeout(event)}};return{dispatchErrorEvent:dispatchErrorEvent,dispatchLoadEvent:dispatchLoadEvent,dispatchReadyStateChangeEvent:dispatchReadyStateChangeEvent,dispatchTimeoutEvent:dispatchTimeoutEvent}};const StatusCodeToTextMap={200:StatusText.OK,201:StatusText.Created,202:StatusText.Accepted,203:StatusText.NonAuthoritativeInformation,204:StatusText.NoContent,205:StatusText.ResetContent,206:StatusText.PartialContent,207:StatusText.MultiStatus,208:StatusText.AlreadyReported,226:StatusText.IMUsed,400:StatusText.BadRequest,401:StatusText.Unauthorized,402:StatusText.PaymentRequired,403:StatusText.Forbidden,404:StatusText.NotFound,405:StatusText.MethodNotAllowed,406:StatusText.NotAcceptable,408:StatusText.RequestTimeout,409:StatusText.Conflict,410:StatusText.Gone,411:StatusText.LengthRequired,412:StatusText.PreconditionFailed,413:StatusText.PayloadTooLarge,414:StatusText.URITooLong,415:StatusText.UnsupportedMediaType,416:StatusText.RangeNotSatisfiable,417:StatusText.ExpectationFailed,421:StatusText.MisdirectedRequest,422:StatusText.UnprocessableEntity,423:StatusText.Locked,424:StatusText.FailedDependency,426:StatusText.UpgradeRequired,428:StatusText.PreconditionRequired,429:StatusText.TooManyRequests,431:StatusText.RequestHeaderFieldsTooLarge,451:StatusText.UnavailableForLegalReasons,500:StatusText.InternalServerError,501:StatusText.NotImplemented,502:StatusText.BadGateway,503:StatusText.ServiceUnavailable,504:StatusText.GatewayTimeout,505:StatusText.HTTPVersionNotSupported,506:StatusText.VariantAlsoNegotiates,507:StatusText.InsufficientStorage,508:StatusText.LoopDetected,510:StatusText.NotExtended,511:StatusText.NetworkAuthenticationRequired};const decodeResponseBody=responseBodyAsHexString=>{if(responseBodyAsHexString===null||responseBodyAsHexString===undefined){return null}try{return hexStringToBytes(responseBodyAsHexString)}catch(err){console.error(err);return null}};const getStatusTextForCode=statusCode=>StatusCodeToTextMap[statusCode]||StatusText.Unknown;const isFileRequest=requestUrl=>requestUrl.indexOf("file://")===0;const isForbiddenHttpMethod=httpMethod=>includes(FORBIDDEN_HTTP_METHODS,httpMethod.toLowerCase());const isForbiddenRequestHeader=header=>{header=header.toLowerCase();return includes(FORBIDDEN_REQUEST_HEADERS,header)||FORBIDDEN_REQUEST_HEADERS_RE.some((headerRe=>headerRe.test(header)))};const isHttpMethodValid=httpMethod=>HTTP_METHOD_RE.test(httpMethod);const isHttpStatusOK=statusCode=>statusCode>=200&&statusCode<300;const isStandardHttpMethod=method=>includes(STANDARD_HTTP_METHODS,method.toLowerCase());const normalizeHttpMethod=httpMethod=>{httpMethod=String(httpMethod);if(isStandardHttpMethod(httpMethod)){return httpMethod.toUpperCase()}return httpMethod};const NativeXMLHttpRequest=globalContext.XMLHttpRequest;const parseHeaders=headersAsText=>headersAsText.split("\n").reduce(((headers,headerAsText)=>{const parts=headerAsText.split(":");const name=(parts[0]||"").trim();headers[name]=(parts[1]||"").trim();return headers}),{});const loadFile=(fileUrl,onLoad,onError)=>{const xhr=new NativeXMLHttpRequest;xhr.onload=()=>{onLoad(xhr.response,parseHeaders(xhr.getAllResponseHeaders()))};xhr.onerror=onError;xhr.open("GET",fileUrl);xhr.send()};const readFileAsArrayBuffer=file=>new Promise(((resolve,reject)=>{const reader=new FileReader;reader.onloadend=()=>{if(reader.error){reject(reader.error)}else{const result=reader.result;if(result instanceof ArrayBuffer){resolve(result)}else{reject("Could not read the file content as ArrayBuffer")}}};reader.readAsArrayBuffer(file)}));const mergeUint8Arrays=(...arrays)=>{let totalLength=0;for(const arr of arrays){totalLength+=arr.length}const result=new Uint8Array(totalLength);let offset=0;for(const arr of arrays){result.set(arr,offset);offset+=arr.length}return result};const contentDispositionBytes=stringToBytes("Content-Disposition: form-data; ");const contentTypeBytes=stringToBytes("Content-Type: ");const defaultContentTypeBytes=stringToBytes("application/octet-stream");const doubleDashBytes=stringToBytes("--");const doubleQuoteBytes=stringToBytes('"');const nameBytes=stringToBytes("name=");const fileNameBytes=stringToBytes(" filename=");const semicolonBytes=stringToBytes(";");const lineBreakBytes=new Uint8Array([13,10]);const generateBoundary=()=>{const id="xxxxxxxxxxxxxxxx".replace(/[xy]/g,(c=>{const r=Math.random()*16|0;const v=c==="x"?r:r&3|8;return v.toString(16)}));return`----WebKitFormBoundary${id}`};const escapeForbiddenChars=key=>key.replace(/"/g,"%22").replace(/\r/g,"%0D").replace(/\n/g,"%0A");const formDataEntries=formData=>{if(!formData.entries){throw createDOMException(`Failed to send FormData: FormData#entries() is not supported.`)}return Array.from(formData.entries())};const formEntryData=(name,value)=>__awaiter(void 0,void 0,void 0,(function*(){const result=[];name=escapeForbiddenChars(name);result.push(contentDispositionBytes,nameBytes,doubleQuoteBytes,stringToBytes(name),doubleQuoteBytes);if(isFile(value)){const file=value;result.push(semicolonBytes,fileNameBytes,doubleQuoteBytes,stringToBytes(escapeForbiddenChars(file.name)),doubleQuoteBytes,lineBreakBytes);result.push(contentTypeBytes,file.type?stringToBytes(file.type):defaultContentTypeBytes,lineBreakBytes);const valueAsArrayBuffer=yield readFileAsArrayBuffer(file);const valueAsByteArray=new Uint8Array(valueAsArrayBuffer);result.push(lineBreakBytes,valueAsByteArray)}else{result.push(lineBreakBytes,lineBreakBytes,stringToBytes(value))}return result}));const formDataAsByteArray=(formData,boundaryBytes)=>__awaiter(void 0,void 0,void 0,(function*(){const entryList=formDataEntries(formData);const entryPromiseList=entryList.map((entry=>formEntryData(entry[0],entry[1])));const result=[];for(const entryPromise of entryPromiseList){const entry=yield entryPromise;result.push(doubleDashBytes,boundaryBytes);result.push(lineBreakBytes);result.push(...entry);result.push(lineBreakBytes)}if(entryList.length>0){result.push(doubleDashBytes,boundaryBytes,doubleDashBytes);result.push(lineBreakBytes)}return mergeUint8Arrays(...result)}));const fromFormData=formData=>__awaiter(void 0,void 0,void 0,(function*(){const boundary=generateBoundary();const boundaryBytes=stringToBytes(boundary);const body=yield formDataAsByteArray(formData,boundaryBytes);const contentLength=body.byteLength;const contentType=`multipart/form-data; boundary=${boundary}`;return{body:body,contentLength:contentLength,contentType:contentType}}));const fromHTMLDocument=htmlDocument=>{const html=htmlDocument.documentElement.outerHTML;const body=stringToBytes(html);const contentLength=body.length;const contentType=DEFAULT_MIME_TYPE_TEXT_HTML;return Promise.resolve({body:body,contentLength:contentLength,contentType:contentType})};const fromPlainText=text=>{const body=stringToBytes(text);const contentLength=body.length;const contentType=DEFAULT_MIME_TYPE_TEXT_PLAIN;return Promise.resolve({body:body,contentLength:contentLength,contentType:contentType})};const extractBody=body=>{if(isHTMLDocument(body)){return fromHTMLDocument(body)}if(isFormData(body)){return fromFormData(body)}return fromPlainText(body)};class ArrayBufferBodyParser{parse(responseBodyAsByteArray){return responseBodyAsByteArray.buffer}}class DocumentBodyParser{constructor(domParser){this.domParser=domParser}parse(responseBodyAsByteArray,responseMimeType){const isSupportedMimeType=responseMimeType&&SUPPORTED_RESPONSE_TYPE_DOCUMENT_MIME_TYPE.indexOf(responseMimeType)!==-1;const mimeType=isSupportedMimeType?responseMimeType:"text/html";return this.domParser.parseFromString(byteArrayToString(responseBodyAsByteArray),mimeType)}}class JSONBodyParser{parse(responseBodyAsByteArray){try{return JSON.parse(byteArrayToString(responseBodyAsByteArray))}catch(err){return null}}}class TextBodyParser{parse(responseBodyAsByteArray){try{return byteArrayToString(responseBodyAsByteArray)}catch(err){return null}}}var ReadyState;(function(ReadyState){ReadyState[ReadyState["Unsent"]=0]="Unsent";ReadyState[ReadyState["Opened"]=1]="Opened";ReadyState[ReadyState["HeadersReceived"]=2]="HeadersReceived";ReadyState[ReadyState["Loading"]=3]="Loading";ReadyState[ReadyState["Done"]=4]="Done"})(ReadyState||(ReadyState={}));class XMLHttpRequestUpload extends XMLHttpRequestEventTarget{}makeMembersEnumerable(XMLHttpRequestUpload.prototype);applyCustomToString(XMLHttpRequestUpload.prototype);class XMLHttpRequestInternals{constructor(){this.onreadystatechangeValue=null;this.uploadValue=new XMLHttpRequestUpload;this.reset()}get onreadystatechange(){return this.onreadystatechangeValue}set onreadystatechange(handler){if(isFunction(handler)){this.onreadystatechangeValue=handler}}get parsedResponseBody(){return this.parsedResponseBodyValue}set parsedResponseBody(parsedResponseBody){this.parsedResponseBodyValue=parsedResponseBody}get readyState(){return this.readyStateValue}set readyState(readyState){this.readyStateValue=readyState}get requestBodyAsByteArray(){return this.requestBodyAsByteArrayValue}set requestBodyAsByteArray(requestBodyAsByteArray){this.requestBodyAsByteArrayValue=requestBodyAsByteArray}get requestHeaders(){return this.requestHeadersValue}set requestHeaders(requestHeaders){this.requestHeadersValue=requestHeaders}get requestMethod(){return this.requestMethodValue}set requestMethod(requestMethod){this.requestMethodValue=requestMethod}get requestSent(){return this.requestSentValue}set requestSent(requestSent){this.requestSentValue=requestSent}get requestUrl(){return this.requestUrlValue}set requestUrl(requestUrl){this.requestUrlValue=requestUrl}get responseBodyAsByteArray(){return this.responseBodyAsByteArrayValue}set responseBodyAsByteArray(responseBodyAsByteArray){if(this.responseBodyAsByteArrayValue){this.responseBodyAsByteArrayValue=mergeUint8Arrays(this.responseBodyAsByteArrayValue,responseBodyAsByteArray)}else{this.responseBodyAsByteArrayValue=responseBodyAsByteArray}}get responseBodyConsumed(){return this.responseBodyConsumedValue}set responseBodyConsumed(responseBodyConsumed){this.responseBodyConsumedValue=responseBodyConsumed}get responseHeaders(){return this.responseHeadersValue}set responseHeaders(responseHeaders){this.responseHeadersValue=responseHeaders}get responseType(){return this.responseTypeValue}set responseType(responseType){if(includes(SUPPORTED_RESPONSE_TYPE,responseType)){const canUpdate=this.readyState<ReadyState.Loading;if(!canUpdate){throw createDOMException(`InvalidStateError: Failed to set the 'responseType' property on 'XMLHttpRequest': `+`The response type cannot be set if the object's state is LOADING or DONE.`)}this.responseTypeValue=responseType}else{console.warn(`The provided value '${responseType}' is not a valid enum value `+`of type XMLHttpRequestResponseType`)}}get responseURL(){return this.responseURLValue}set responseURL(responseURL){this.responseURLValue=responseURL}get status(){return this.statusValue}set status(status){this.statusValue=status}get statusText(){return this.statusTextValue}set statusText(statusText){this.statusTextValue=statusText}get timeout(){return this.timeoutValue}set timeout(timeout){this.timeoutValue=timeout}get upload(){return this.uploadValue}set upload(upload){this.uploadValue=upload}addRequestHeader(header,value){const existingHeader=this.getCaseInsensitiveRequestHeader(header);const normalizedValue=value.trim();if(existingHeader){const previousValue=this.requestHeaders[existingHeader];this.requestHeaders[existingHeader]=`${previousValue}, ${normalizedValue}`}else{this.requestHeaders[header]=normalizedValue}}getCaseInsensitiveRequestHeader(header){const headerToSearch=header.toLowerCase();const existingHeaders=Object.keys(this.requestHeaders);return find(existingHeaders,(headerToCheck=>headerToCheck.toLowerCase()===headerToSearch))}getProcessedResponseHeaders(){const headers=this.responseHeaders;return Object.keys(headers).map((header=>[header.toLowerCase(),headers[header]])).sort((([headerA],[headerB])=>headerA.localeCompare(headerB)))}hasCaseInsensitiveRequestHeader(header){return this.getCaseInsensitiveRequestHeader(header)!==void 0}reset(initialValues){this.parsedResponseBodyValue=null;this.readyStateValue=ReadyState.Unsent;this.requestBodyAsByteArrayValue=null;this.requestHeadersValue={};this.requestMethodValue="";this.requestSentValue=false;this.requestUrlValue="";this.responseBodyAsByteArrayValue=null;this.responseBodyConsumedValue=false;this.responseHeadersValue={};this.responseTypeValue="";this.responseURLValue="";this.status=0;this.statusText="";this.timeout=0;this.uploadValue=new XMLHttpRequestUpload;if(initialValues){Object.assign(this,initialValues)}}}const createCustomXHRImplementation=(bbxhrPlugin,domParser,urlParser,language)=>{const createError=createErrorFactory("hsdk-core");const eventDispatcher=createEventDispatcher();const arrayBufferBodyParser=new ArrayBufferBodyParser;const documentBodyParser=new DocumentBodyParser(domParser);const jsonBodyParser=new JSONBodyParser;const textBodyParser=new TextBodyParser;const setRequestBodyAndContentType=(instance,requestBody)=>__awaiter(void 0,void 0,void 0,(function*(){let requestBodyAsByteArray=null;const internalState=getInternals(instance);if(internalState.requestMethod==="GET"||internalState.requestMethod==="HEAD"){requestBody=null}if(requestBody!==null&&requestBody!==undefined){const extractedRequestBody=yield extractBody(requestBody);const contentLength=extractedRequestBody.contentLength;setRequestHeader(instance,"Content-Length",String(contentLength),true);const originalAuthorContentType=getRequestHeader(instance,"Content-Type");requestBodyAsByteArray=extractedRequestBody.body;if(!originalAuthorContentType){const extractedContentType=extractedRequestBody.contentType;if(extractedContentType){setRequestHeader(instance,"Content-Type",extractedContentType,true)}}}internalState.requestBodyAsByteArray=requestBodyAsByteArray}));const getInternals=instance=>instance[INTERNALS_KEY$2];const getRequestHeader=(instance,header)=>{const value=getInternals(instance).getCaseInsensitiveRequestHeader(header);return value!==void 0?value:null};const getAllRequestHeaders=instance=>{const internalState=getInternals(instance);const authorRequestHeaders=internalState.requestHeaders;const defaultRequestHeaders={};const systemRequestHeaders={"bb.nsurlrequest.webview":"true"};if(!internalState.hasCaseInsensitiveRequestHeader("Accept")){defaultRequestHeaders["Accept"]="*/*"}if(!internalState.hasCaseInsensitiveRequestHeader("Accept-Language")){defaultRequestHeaders["Accept-Language"]=language}return Object.assign(defaultRequestHeaders,authorRequestHeaders,systemRequestHeaders)};const handlePluginError=(instance,pluginError)=>{const internalState=getInternals(instance);if(!internalState.requestSent){return}console.debug(`[bbxhr] Request failed:`,pluginError);printRequestError(instance,pluginError);if(pluginError.name===BBXHRPluginRequestErrorName.RequestTimeout){handleTimeout(instance);return}handleNetworkError(instance)};const handlePluginResponse=(instance,pluginResponse)=>{const internalState=getInternals(instance);const canReadHeaders=pluginResponse.readyState===BBXHRPluginReadyState.HeadersReceived;const canReadBody=pluginResponse.readyState===BBXHRPluginReadyState.Loading||pluginResponse.readyState===BBXHRPluginReadyState.Complete;const readyState=pluginResponseToReadyState(pluginResponse);const readyStateChanged=readyState!==internalState.readyState;if(canReadHeaders){internalState.responseHeaders=pluginResponse.headers;internalState.status=pluginResponse.status;internalState.statusText=getStatusTextForCode(pluginResponse.status);internalState.responseURL=pluginResponse.responseURL}if(canReadBody){internalState.responseBodyAsByteArray=decodeResponseBody(pluginResponse.body);internalState.responseBodyConsumed=false}if(readyStateChanged){internalState.readyState=readyState;eventDispatcher.dispatchReadyStateChangeEvent(instance);if(internalState.readyState===ReadyState.Done){internalState.requestSent=false;eventDispatcher.dispatchLoadEvent(instance);console.debug(`[bbxhr] Request complete:`,{get body(){return instance.response},headers:internalState.responseHeaders,get rawBody(){return internalState.responseBodyAsByteArray},responseURL:internalState.responseURL,status:internalState.status,statusText:internalState.statusText});if(!isHttpStatusOK(internalState.status)){printRequestError(instance)}}}};const handleNetworkError=instance=>{const internalState=getInternals(instance);internalState.status=0;internalState.statusText="";internalState.readyState=ReadyState.Done;eventDispatcher.dispatchReadyStateChangeEvent(instance);eventDispatcher.dispatchErrorEvent(instance)};const handleTimeout=instance=>{const internalState=getInternals(instance);internalState.status=0;internalState.statusText="";internalState.readyState=ReadyState.Done;eventDispatcher.dispatchReadyStateChangeEvent(instance);eventDispatcher.dispatchTimeoutEvent(instance)};let isFileSchemeSupportedByPlugin=null;const shouldUsePlugin=(requestUrl,callback)=>{if(!isFileRequest(requestUrl)){callback(true);return}if(isFileSchemeSupportedByPlugin!==null){callback(isFileSchemeSupportedByPlugin);return}bbxhrPlugin.isFileSchemeSupported((response=>{isFileSchemeSupportedByPlugin=response==="true"||response===true;callback(isFileSchemeSupportedByPlugin)}),(()=>{isFileSchemeSupportedByPlugin=false;callback(isFileSchemeSupportedByPlugin)}))};const isResponseAvailable=(responseType,readyState)=>{if(isTextResponse(responseType)||isBinaryResponse(responseType)){return readyState===ReadyState.HeadersReceived||readyState===ReadyState.Loading||readyState===ReadyState.Done}return readyState===ReadyState.Done};const getEmptyResponse=responseType=>isTextResponse(responseType)?"":null;const isBinaryResponse=responseType=>responseType==="arraybuffer";const isTextResponse=responseType=>responseType===""||responseType==="text";const printRequestError=(instance,pluginError)=>{const internalState=getInternals(instance);const requestMethod=internalState.requestMethod;const requestUrl=internalState.requestUrl;const errorText=pluginError?pluginError.name:`${internalState.status} ${internalState.statusText}`;console.error(`${requestMethod} ${requestUrl} ${errorText}`)};const normalizeTimeout=timeout=>{timeout=Number(timeout);return isFiniteNumber(timeout)&&!isNegativeZero(timeout)?timeout:0};const parseResponseBody=(responseBodyAsByteArray,responseType,responseMimeType)=>{if(responseBodyAsByteArray===null){return isTextResponse(responseType)?"":null}if(isTextResponse(responseType)){return textBodyParser.parse(responseBodyAsByteArray)}if(responseType==="json"){return jsonBodyParser.parse(responseBodyAsByteArray)}if(responseType==="document"){return documentBodyParser.parse(responseBodyAsByteArray,responseMimeType)}if(responseType==="arraybuffer"){return arrayBufferBodyParser.parse(responseBodyAsByteArray)}return null};const pluginResponseToReadyState=pluginResponse=>{const pluginReadyState=pluginResponse.readyState;if(pluginReadyState===BBXHRPluginReadyState.HeadersReceived){return ReadyState.HeadersReceived}if(pluginReadyState===BBXHRPluginReadyState.Loading){return ReadyState.Loading}if(pluginReadyState===BBXHRPluginReadyState.Complete){return ReadyState.Done}return ReadyState.Opened};const abort=instance=>{};const onreadystatechangeGetter=instance=>getInternals(instance).onreadystatechange;const onreadystatechangeSetter=(instance,listener)=>{getInternals(instance).onreadystatechange=listener};const getResponseHeader=(instance,header)=>{const{responseHeaders:responseHeaders}=getInternals(instance);header=header.toLowerCase();for(const responseHeader in responseHeaders){if({}.hasOwnProperty.call(responseHeaders,responseHeader)&&responseHeader.toLowerCase()===header){return responseHeaders[responseHeader]}}return null};const getAllResponseHeaders=instance=>getInternals(instance).getProcessedResponseHeaders().map((([header,value])=>`${header}: ${value}`)).join("\n");const open=(instance,requestMethod,requestUrl)=>{const internalState=getInternals(instance);const readyState=ReadyState.Opened;const timeout=internalState.timeout;requestMethod=normalizeHttpMethod(requestMethod);if(!isHttpMethodValid(requestMethod)){throw createDOMException(`Failed to execute 'open' on 'XMLHttpRequest': '${requestMethod}' is not a valid HTTP method.`)}if(isForbiddenHttpMethod(requestMethod)){throw createDOMException(`Failed to execute 'open' on 'XMLHttpRequest': '${requestMethod}' HTTP method is unsupported`)}requestUrl=urlParser.toAbsoluteURI(requestUrl);if(!requestUrl){throw createDOMException(`Failed to execute 'open' on 'XMLHttpRequest': Invalid URL`)}internalState.reset({readyState:readyState,requestMethod:requestMethod,requestUrl:requestUrl,timeout:timeout});eventDispatcher.dispatchReadyStateChangeEvent(instance)};const overrideMimeType=(instance,mime)=>{};const readyStateGetter=instance=>getInternals(instance).readyState;const responseGetter=instance=>{const internalState=getInternals(instance);const readyState=internalState.readyState;const responseBodyAsByteArray=internalState.responseBodyAsByteArray;const responseBodyConsumed=internalState.responseBodyConsumed;const responseType=internalState.responseType;if(!isResponseAvailable(responseType,readyState)){return getEmptyResponse(responseType)}if(!responseBodyConsumed){const responseMimeType=getResponseHeader(instance,HEADER_CONTENT_TYPE);internalState.parsedResponseBody=parseResponseBody(responseBodyAsByteArray,responseType,responseMimeType);internalState.responseBodyConsumed=true}return internalState.parsedResponseBody};const responseTextGetter=instance=>{const internalState=getInternals(instance);const responseType=internalState.responseType;if(!isTextResponse(responseType)){throw createDOMException(`InvalidStateError: Failed to read the 'responseText' property from 'XMLHttpRequest': `+`The value is only accessible if the object's 'responseType' is '' or 'text'`+` (was '${responseType}')`)}return instance.response||""};const responseTypeGetter=instance=>getInternals(instance).responseType;const responseTypeSetter=(instance,responseType)=>{getInternals(instance).responseType=responseType};const responseURLGetter=instance=>getInternals(instance).responseURL;const send=(instance,body)=>{const internalState=getInternals(instance);const{requestSent:requestSent,requestUrl:requestUrl}=internalState;if(!bbxhrPlugin){throw createError(`Failed to execute 'send' on 'XMLHttpRequest': The plugin is not found`)}if(instance.readyState!==ReadyState.Opened){throw createDOMException(`InvalidStateError: Failed to execute 'send' on 'XMLHttpRequest': `+`The object's state must be OPENED`)}if(requestSent){throw createDOMException(`InvalidStateError: Failed to execute 'send' on 'XMLHttpRequest': `+`XMLHttpRequest must not be sending`)}setRequestBodyAndContentType(instance,body).then((()=>{shouldUsePlugin(requestUrl,(usePlugin=>{if(usePlugin){makeRequestUsingPlugin(instance)}else{makeRequestUsingNativeXHR(instance)}}))})).catch((error=>{throw error}));internalState.requestSent=true};const makeRequestUsingNativeXHR=instance=>{const internalState=getInternals(instance);const{requestUrl:requestUrl}=internalState;const onLoad=(fileContent,headers)=>{internalState.status=200;internalState.statusText="OK";internalState.readyState=ReadyState.Done;internalState.parsedResponseBody=fileContent;internalState.responseBodyConsumed=true;internalState.responseHeaders=headers;internalState.responseURL=requestUrl;eventDispatcher.dispatchReadyStateChangeEvent(instance);internalState.requestSent=false;eventDispatcher.dispatchLoadEvent(instance)};const onFail=()=>{if(!internalState.requestSent){return}handleNetworkError(instance)};loadFile(requestUrl,onLoad,onFail)};const makeRequestUsingPlugin=instance=>{const internalState=getInternals(instance);const requestBodyAsByteArray=internalState.requestBodyAsByteArray;const body=requestBodyAsByteArray?bytesToHexString(requestBodyAsByteArray):"";const headers=getAllRequestHeaders(instance);const method=internalState.requestMethod;const timeout=internalState.timeout||DEFAULT_PLUGIN_TIMEOUT;const url=internalState.requestUrl;bbxhrPlugin.makeRequest((pluginResponse=>handlePluginResponse(instance,pluginResponse)),(pluginError=>handlePluginError(instance,pluginError)),requestConfigToJSONString({body:body,headers:headers,method:method,timeout:timeout,url:url}));console.debug(`[bbxhr] Request sent:`,{get body(){return requestBodyAsByteArray?byteArrayToString(requestBodyAsByteArray):null},headers:headers,method:method,get rawBody(){return requestBodyAsByteArray},timeout:timeout,url:url})};const setRequestHeader=(instance,header,value,internalCall=false)=>{const internalState=getInternals(instance);if(!internalCall&&(internalState.readyState!==ReadyState.Opened||internalState.requestSent)){throw createDOMException(`InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': `+`The object's state must be OPENED`)}header=String(header);value=String(value);if(!internalCall&&isForbiddenRequestHeader(header)){console.error(`Refused to set unsafe header "${header}"`);return}getInternals(instance).addRequestHeader(header,value)};const statusGetter=instance=>getInternals(instance).status;const statusTextGetter=instance=>getInternals(instance).statusText;const timeoutGetter=instance=>getInternals(instance).timeout;const timeoutSetter=(instance,timeout)=>{getInternals(instance).timeout=normalizeTimeout(timeout)};const uploadGetter=instance=>getInternals(instance).upload;const construct=instance=>{Object.defineProperty(instance,INTERNALS_KEY$2,{value:new XMLHttpRequestInternals})};return{abort:abort,construct:construct,getAllResponseHeaders:getAllResponseHeaders,getResponseHeader:getResponseHeader,makeRequestUsingNativeXHR:makeRequestUsingNativeXHR,makeRequestUsingPlugin:makeRequestUsingPlugin,onreadystatechangeGetter:onreadystatechangeGetter,onreadystatechangeSetter:onreadystatechangeSetter,open:open,overrideMimeType:overrideMimeType,readyStateGetter:readyStateGetter,responseGetter:responseGetter,responseTextGetter:responseTextGetter,responseTypeGetter:responseTypeGetter,responseTypeSetter:responseTypeSetter,responseURLGetter:responseURLGetter,send:send,setRequestHeader:setRequestHeader,statusGetter:statusGetter,statusTextGetter:statusTextGetter,timeoutGetter:timeoutGetter,timeoutSetter:timeoutSetter,uploadGetter:uploadGetter}};const makeXMLHttpRequest=(bbxhrPlugin,domParser,urlParser,language)=>{const implementation=createCustomXHRImplementation(bbxhrPlugin,domParser,urlParser,language);class XMLHttpRequest extends XMLHttpRequestEventTarget{constructor(){super();implementation.construct(this)}get onreadystatechange(){return implementation.onreadystatechangeGetter(this)}set onreadystatechange(listener){implementation.onreadystatechangeSetter(this,listener)}get readyState(){return implementation.readyStateGetter(this)}get response(){return implementation.responseGetter(this)}get responseText(){return implementation.responseTextGetter(this)}set responseText(responseText){}get responseType(){return implementation.responseTypeGetter(this)}set responseType(responseType){implementation.responseTypeSetter(this,responseType)}get responseURL(){return implementation.responseURLGetter(this)}get responseXML(){return null}set responseXML(responseXML){}get status(){return implementation.statusGetter(this)}get statusText(){return implementation.statusTextGetter(this)}get timeout(){return implementation.timeoutGetter(this)}set timeout(timeout){implementation.timeoutSetter(this,timeout)}get upload(){return implementation.uploadGetter(this)}get withCredentials(){return true}set withCredentials(withCredentials){}abort(){return implementation.abort(this)}getAllResponseHeaders(){return implementation.getAllResponseHeaders(this)}getResponseHeader(header){return implementation.getResponseHeader(this,header)}open(requestMethod,requestUrl){if(arguments.length<2){throw createPlainTypeError(`Failed to execute 'open' on 'XMLHttpRequest': 2 arguments required, but only ${arguments.length} present.`)}return implementation.open(this,requestMethod,requestUrl)}overrideMimeType(mime){return implementation.overrideMimeType(this,mime)}send(body){implementation.send(this,body)}setRequestHeader(header,value){if(arguments.length<2){throw createPlainTypeError(`Failed to execute 'setRequestHeader' on 'XMLHttpRequest': `+`2 arguments required, but only ${arguments.length} present.`)}return implementation.setRequestHeader(this,header,value)}}const XMLHttpRequestProto=XMLHttpRequest.prototype;exposeConstant(XMLHttpRequest,READY_STATE_DONE,ReadyState.Done);exposeConstant(XMLHttpRequest,READY_STATE_HEADERS_RECEIVED,ReadyState.HeadersReceived);exposeConstant(XMLHttpRequest,READY_STATE_LOADING,ReadyState.Loading);exposeConstant(XMLHttpRequest,READY_STATE_OPENED,ReadyState.Opened);exposeConstant(XMLHttpRequest,READY_STATE_UNSENT,ReadyState.Unsent);exposeConstant(XMLHttpRequestProto,READY_STATE_DONE,ReadyState.Done);exposeConstant(XMLHttpRequestProto,READY_STATE_HEADERS_RECEIVED,ReadyState.HeadersReceived);exposeConstant(XMLHttpRequestProto,READY_STATE_LOADING,ReadyState.Loading);exposeConstant(XMLHttpRequestProto,READY_STATE_OPENED,ReadyState.Opened);exposeConstant(XMLHttpRequestProto,READY_STATE_UNSENT,ReadyState.Unsent);makeMembersEnumerable(XMLHttpRequestProto);applyCustomToString(XMLHttpRequestProto);return XMLHttpRequest};const enableBBXHR=bbxhrPlugin=>{const domParser=createDOMParser();const urlParser=createURLParser();const language=navigator.language;const XMLHttpRequest=makeXMLHttpRequest(bbxhrPlugin,domParser,urlParser,language);Object.assign(window,{XMLHttpRequest:XMLHttpRequest})};const isConstructibleXHREventTargetSupported=()=>{try{new window.XMLHttpRequestEventTarget;return true}catch(error){return false}};const XMLHttpRequestEventTarget$1=isConstructibleXHREventTargetSupported()?window.EventTarget:XMLHttpRequestEventTarget;const exposeXHREventTargetIfNeeded=()=>{if(window.XMLHttpRequestEventTarget!==XMLHttpRequestEventTarget$1){Object.assign(window,{XMLHttpRequestEventTarget:XMLHttpRequestEventTarget$1})}};const enable=(config,injectedNativePlugins)=>{const bbxhrPlugin=injectedNativePlugins[BBXHRPluginName];if(!{}.hasOwnProperty.call(bbxhrPlugin,"isFileSchemeSupported")){bbxhrPlugin.isFileSchemeSupported=(onSuccess,onError)=>{setTimeout((()=>{onSuccess("true")}),0)}}exposeXHREventTargetIfNeeded();enableBBXHR(bbxhrPlugin)};exports.enable=enable;Object.defineProperty(exports,"__esModule",{value:true})})(this["@backbase/bbxhr"]=this["@backbase/bbxhr"]||{});
